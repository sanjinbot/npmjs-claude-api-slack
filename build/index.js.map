{"version":3,"sources":["../src/index.ts","../src/types.ts"],"sourcesContent":["import { WebClient } from '@slack/web-api'\nimport delay from 'delay'\nimport { v4 as uuidv4 } from 'uuid'\nimport pTimeout from 'p-timeout'\nimport * as types from './types'\n\nconst DAY_MS = 1000 * 60 * 60 * 24\nconst TYPING = '_Typingâ€¦_'\nconst WAIT_MS = 1000 * 15\n\nfunction dat() {\n  return new Date()\n    .getTime()\n}\n\nfunction str(json: Object) {\n  return JSON.stringify(json)\n}\n\n\n\nclass Authenticator {\n  private debug?: boolean\n\n  private bot?: string\n  private token?: string\n  private channelTs = new Map<string, string>()\n  private client?: WebClient\n\n  constructor(token: string, bot: string, debug: boolean = false) {\n    this.bot = bot\n    this.token = token\n    this.client = new WebClient( this.token )\n    this.debug = debug\n  }\n\n   async oauth2(clientId: string, clientSecret: string): Promise<string> {\n    const result = await this.client.oauth.v2.exchange({\n      client_id: clientId,\n      client_secret: clientSecret\n    })\n    // TODO -\n    console.log(result)\n    return 'ok'\n  }\n\n\n  async newChannel(name: string): Promise<string> {\n    const conversations = await this.client?.conversations.list({ limit: 2000 })\n    if (!conversations?.ok) {\n      const error = new types.ClaudeError(conversations?.error)\n      error.statusCode = 5001\n      error.statusText = 'method `conversations.list` error.'\n      throw error\n    }\n\n    const conversation = conversations?.channels?.find(it => it.name === name)\n    if (conversation) {\n      return conversation.id\n    }\n\n    const result = await this.client?.conversations.create({ name })\n\n    if (result.ok) {\n      this._joinChannel(result.channel.id, this.bot, name)\n      return result.channel.id\n    }\n\n    const error = new types.ClaudeError(result.error)\n    error.statusCode = 5002\n    error.statusText = 'method `conversations.create` error.'\n    throw error\n  }\n\n  private async _joinChannel(channel: string, users: string, name: string) {\n    const result = await this.client?.conversations.invite({ channel, users })\n    if (!result.ok) {\n      await this._deleteChannel(channel, name)\n      const error = new types.ClaudeError(result.error)\n      error.statusCode = 5003\n      error.statusText = 'method `conversations.invite` error.'\n      throw error\n    }\n  }\n\n  private async _deleteChannel(channel: string, name: string) {\n    const result = await this.client?.conversations.rename({\n      channel, name: name + dat()\n    })\n    if (result.ok) {\n      await this.client?.conversations.leave({ channel })\n    }\n  }\n\n\n  async sendMessage(opt: {\n    text: string,\n    channel: string\n    conversationId?: string\n    onMessage?: (partialResponse: types.ChatResponse) => void,\n    timeoutMs?: number,\n    retry?: number\n  }): Promise<types.ChatResponse> {\n    const {\n      text,\n      channel,\n      conversationId = uuidv4(),\n      onMessage,\n      timeoutMs,\n      retry = 3\n    } = opt\n\n    let ts = this.channelTs.get(conversationId)\n    if (this.debug) {\n      console.log('claude-api mthod `sendMessage` current thread_ts: ', ts)\n    }\n\n    let result = null, retryCount = 0, currTime = 0\n\n    const reply = async () => {\n      currTime = dat()\n      result = await this.client?.chat.postMessage({\n        text: `<@${this.bot}>\\n${text}`,\n        thread_ts: ts,\n        channel\n      })\n\n      if (!this.channelTs.has(conversationId)) {\n        this.channelTs.set(conversationId, result.ts)\n        ts = result.ts\n      }\n    }\n\n    await reply()\n\n    const responseP = new Promise<types.ChatResponse>(async (resolve, reject) => {\n      let resultMessage = '', limit = 1\n\n      const repliesTimeout = async (needRetry: boolean = false): Promise<boolean> => {\n        if (currTime + WAIT_MS < dat()) {\n          if (needRetry && (retry > retryCount)) {\n            retryCount ++\n            await reply()\n            return false\n          }\n          const errorMessage = `method \\`conversations.replies\\` ${WAIT_MS}'ms timeout error.`\n          const error = new types.ClaudeError(errorMessage)\n          error.statusCode = 5004\n          error.statusText = 'method `conversations.replies` timeout error'\n          reject(error)\n          return true\n        } else return false\n      }\n\n      while (1) {\n        const partialResponse = await this.client?.conversations.replies({ channel, ts, limit })\n        if (!partialResponse.ok) {\n          if (await repliesTimeout()) {\n            return\n          }\n          await delay(500)\n          continue\n        }\n\n        if (this.debug) {\n          console.log('claude-api mthod `sendMessage` partialResponse', partialResponse.messages)\n        }\n\n        const messages = partialResponse.messages.filter(it => result.message.bot_id !== it.bot_id)\n        const message = messages[messages.length - limit]\n\n        if (message) {\n          if (message.metadata?.event_type) {\n            if (await repliesTimeout()) return\n            limit = 2\n            await delay(500)\n            continue\n          }\n\n          if (message.text) resultMessage = message.text\n          if (onMessage && message.text !== TYPING) {\n            onMessage({\n              text: message.text?.replace(TYPING, ''),\n              conversationId,\n              channel\n            })\n          }\n          if (!message.text || !message.text.endsWith(TYPING)) {\n            break\n          }\n        } else if (await repliesTimeout(/* needRetry */true)) {\n          return\n        }\n        await delay(500)\n      }\n\n      resolve({\n        text: resultMessage,\n        conversationId,\n        channel\n      })\n    })\n\n\n    if (timeoutMs) {\n      return pTimeout(responseP, {\n        milliseconds: timeoutMs,\n        message: 'ClaudeAI timed out waiting for response: ' + timeoutMs + \"'ms.\"\n      })\n    } else {\n      return responseP\n    }\n\n  }\n}\n\nexport { Authenticator }","export class ClaudeError extends Error {\n  statusCode?: number\n  statusText?: string\n  originalError?: Error\n}\n\nexport type ChatResponse = {\n  text: string\n  channel: string\n  conversationId?: string\n}"],"mappings":"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","names":["error"]}
